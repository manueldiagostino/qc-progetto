\section{Implementazione}\label{sec:implementazione}

\subsection{Modellazione circuito}
Come accennato nella sezione \ref{sec:background}, la rappresentazione 
delle immagini viene implementata attraverso la tecnica QPIE. 
Per farlo, si utilizza una matrice associata all'immagine di partenza
i cui elementi corrispondono ai valori d'intensità dei pixel.
Su questa matrice viene effettuato un processo di normalizzazione.
Il risultato è un vettore di stato, composto da ampiezze di
probabilità relative allo stato quantistico del sistema. 
In figura \ref{fig:16x16intensity_img} è mostrata un'immagine di 
dimensione $16 \times 16$ dopo la normalizzazione. Ogni pixel 
con valore ``alto'' rappresenta un risultato della misurazione 
che può essere generata dal circuito con ampiezza di probabilità $0.14$.

\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{16x16.png}
    \caption{Immagine normalizzata (ampiezze di probabilità)}
    \label{fig:16x16intensity_img}
\end{figure}

Dato un vettore di stato composto da $2^n$ elementi, 
il passo successivo consiste nella creazione di un circuito a $n+1$ qubit, 
compreso quello ausiliario o \textit{ancilla qubit}.
La costruzione avviene tramite applicazione di procedure Qiskit \textit{built-in} 
all'oggetto che rappresenta il circuito.
Nel codice \ref{cod:circuit} vengono mostrate le operazioni svolte durante
questa fase, oltre all'applicazione dei gate Hadamard e della matrice 
di permutazione $D_{2^{n+1}}$.

\begin{lstlisting}[language=Python, 
    caption={Codice Python per creazione del circuito}, label=cod:circuit]
# Convert the raw pixel values to probability amplitudes
def amplitude_encode(img_data):
    
    # Calculate the RMS value
    rms = np.sqrt(np.sum(np.sum(img_data**2, axis=1)))
    
    # Create normalized image
    image_norm = []
    for arr in img_data:
        for ele in arr:
            image_norm.append(ele / rms)
        
    # Return the normalized image as a numpy array
    return np.array(image_norm)
# Initialize some global variable for number of qubits
data_qb = math.floor(math.log2(height * width))
anc_qb = 1
total_qb = data_qb + anc_qb

# Initialize the amplitude permutation unitary
D2n_1 = np.roll(np.identity(2**total_qb), 1, axis=1)

# Create the circuit for horizontal scan
qc_h = QuantumCircuit(total_qb)
qc_h.initialize(image_norm_h, range(1, total_qb))
qc_h.h(0)
qc_h.unitary(D2n_1, range(total_qb))
qc_h.h(0)
display(qc_h.draw('mpl', fold=-1))

# Create the circuit for vertical scan
qc_v = QuantumCircuit(total_qb)
qc_v.initialize(image_norm_v, range(1, total_qb))
qc_v.h(0)
qc_v.unitary(D2n_1, range(total_qb))
qc_v.h(0)
display(qc_v.draw('mpl', fold=-1))

# Combine both circuits into a single list
circ_list = [qc_h, qc_v]
\end{lstlisting}

\subsection{Misurazioni}
Le misurazioni vengono svolte inizialmente tramite simulazione, utilizzando 
il framework \texttt{statevector\_simulator}. In questo meccanismo si lavora su 
una simulazione di un circuito quantistico ideale, ovvero senza effetti collaterali come:
\begin{itemize}
    \item fluttuazioni termiche;
    \item interferenza elettromagnetica;
    \item imperfezioni nelle porte quantistiche;
    \item interazioni con l'ambiente;
    \item altre tipologie di \textit{rumore}.
\end{itemize}

Non crea quindi stupore l'immagine risultante ottenuta mediante
questa tecnica, esposta in figura \ref{fig:ideal}. 
In un'esecuzione realistica, tuttavia, occorre tenere in considerazione
le problematiche presentate che, molto spesso, complicano pesantemente
il circuito e richiedono tecniche non banali di \textit{mitigazione dell'errore}.

\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{ideal.png}
    \caption{Edge detection tramite simulazione}
    \label{fig:ideal}
\end{figure}